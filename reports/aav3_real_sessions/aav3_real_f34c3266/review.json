{
  "implementation": "I built a small, self-contained Python module that provides an iterative factorial function with strict input validation and accompanying doctests. The function accepts only integer-like values via operator.index, explicitly rejects bool, raises ValueError for negatives, and TypeError for non-integer inputs. The module includes a __main__ block to run doctests. I also created a unittest suite that covers edge cases (0, 1), typical small values, a larger value cross-checked against math.factorial, recurrence properties, and invalid inputs (negative, floats, strings, bool).",
  "files_to_create": [
    {
      "path": "factorial.py",
      "content": "from typing import SupportsIndex\nimport operator\n\n\ndef factorial(n: SupportsIndex) -> int:\n    \"\"\"\n    Compute the factorial of a non-negative integer.\n\n    Validation rules:\n    - Accepts only integer-like values (SupportsIndex), explicitly rejects bool\n    - Raises ValueError for negative inputs\n    - Raises TypeError for non-integer inputs (including floats)\n\n    Implemented iteratively to avoid recursion depth limits.\n\n    Examples:\n    >>> factorial(0)\n    1\n    >>> factorial(1)\n    1\n    >>> factorial(5)\n    120\n    >>> factorial(True)\n    Traceback (most recent call last):\n    ...\n    TypeError: factorial() does not accept bool; use integers >= 0\n    >>> factorial(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: factorial() not defined for negative values\n    >>> factorial(3.0)\n    Traceback (most recent call last):\n    ...\n    TypeError: factorial() requires an integer-like argument\n    \"\"\"\n    # Reject bool explicitly (bool is a subclass of int)\n    if isinstance(n, bool):\n        raise TypeError(\"factorial() does not accept bool; use integers >= 0\")\n\n    # Convert to a true int via the index protocol; reject non-integers\n    try:\n        k = operator.index(n)\n    except TypeError as e:\n        raise TypeError(\"factorial() requires an integer-like argument\") from e\n\n    if k < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n\n    result = 1\n    for i in range(2, k + 1):\n        result *= i\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    failures, _ = doctest.testmod()\n    raise SystemExit(0 if failures == 0 else 1)\n"
    },
    {
      "path": "tests/test_factorial.py",
      "content": "import unittest\nimport math\n\nfrom factorial import factorial\n\n\nclass TestFactorialValid(unittest.TestCase):\n    def test_zero_and_one(self):\n        self.assertEqual(factorial(0), 1)\n        self.assertEqual(factorial(1), 1)\n\n    def test_small_values(self):\n        for n in [2, 3, 4, 5, 6, 10]:\n            with self.subTest(n=n):\n                self.assertEqual(factorial(n), math.factorial(n))\n\n    def test_larger_value(self):\n        n = 100\n        self.assertEqual(factorial(n), math.factorial(n))\n\n    def test_recurrence_property(self):\n        for n in range(1, 15):\n            with self.subTest(n=n):\n                self.assertEqual(factorial(n), n * factorial(n - 1))\n\n\nclass TestFactorialInvalidInputs(unittest.TestCase):\n    def test_negative_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            factorial(-1)\n\n    def test_non_integers_raise_type_error(self):\n        for x in [5.0, 3.2, \"5\", None, [5]]:\n            with self.subTest(x=x):\n                with self.assertRaises(TypeError):\n                    factorial(x)\n\n    def test_bool_rejected(self):\n        with self.assertRaises(TypeError):\n            factorial(True)\n        with self.assertRaises(TypeError):\n            factorial(False)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
    }
  ],
  "key_decisions": [
    "Validation via operator.index with explicit bool rejection to avoid True/False treating as 1/0.",
    "Iterative loop implementation to avoid recursion depth limits and align with plan.",
    "TypeError for non-integer-like inputs and ValueError for negatives, matching stdlib math.factorial semantics.",
    "Doctests kept minimal and deterministic; __main__ runs doctest for quick checks.",
    "Unittests cross-check against math.factorial for correctness and include property-based recurrence for small n."
  ],
  "status": "complete",
  "_created_files": [
    "reports/aav3_real_sessions/aav3_real_f34c3266/workspace/factorial.py",
    "reports/aav3_real_sessions/aav3_real_f34c3266/workspace/tests/test_factorial.py"
  ]
}