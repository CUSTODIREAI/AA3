{
  "session_id": "aav3_real_0868319d",
  "task": "# Simple Test Task for AAv3 Real\n\nCreate a Python script that calculates the factorial of a number.\n\nRequirements:\n- Function should handle n >= 0\n- Include error handling for negative numbers\n- Add docstring with examples\n- Include basic test cases\n",
  "success": false,
  "reason": "Consensus not reached (60% approval)",
  "duration_sec": 465.55374813079834,
  "messages": 5,
  "artifacts": 3,
  "result": {
    "implementation": "Implemented a type-safe, iterative factorial function with clear doctest examples and a small unittest suite. The function accepts integer-like values via operator.index (e.g., numpy-style ints), explicitly rejects booleans, raises ValueError for negative inputs, and TypeError for non-integral inputs (e.g., floats, strings). Doctests can be run via `python -m factorial`, and unit tests via `python -m unittest -v tests/test_factorial.py`. A concise README includes usage and test instructions.",
    "files_to_create": [
      {
        "path": "factorial.py",
        "content": "'''\\nFactorial utility with strict, predictable validation.\\n\\n- Accepts int and int-like objects via __index__ (e.g., numpy.int64).\\n- Explicitly rejects bools for API clarity.\\n- Raises ValueError for negatives; TypeError for non-integral inputs.\\n- Iterative implementation (avoids recursion depth issues).\\n\\nExamples (doctest):\\n>>> factorial(0)\\n1\\n>>> factorial(5)\\n120\\n>>> factorial(10)\\n3628800\\n\\nErrors (doctest):\\n>>> factorial(-1)\\nTraceback (most recent call last):\\n...\\nValueError: n must be >= 0\\n>>> factorial(3.0)\\nTraceback (most recent call last):\\n...\\nTypeError: n must be an integer-like value (excluding bool)\\n>>> factorial(True)\\nTraceback (most recent call last):\\n...\\nTypeError: n must be an integer-like value (excluding bool)\\n\\nAccept int-like objects via __index__ (doctest):\\n>>> class I:\\n...     def __index__(self): return 4\\n...\\n>>> factorial(I())\\n24\\n'''\\n\\nfrom typing import Any\\nimport operator\\n\\n__all__ = ['factorial']\\n\\n\\ndef factorial(n: int) -> int:\\n    '''\\n    Compute n! for a non-negative integer n using an iterative loop.\\n\\n    Validation rules:\\n    - Reject bool explicitly.\\n    - Accept int-like values via operator.index (e.g., numpy integers).\\n    - Raise ValueError if n < 0.\\n\\n    Returns:\\n        int: The factorial of n.\\n    '''\\n    if isinstance(n, bool):\\n        raise TypeError('n must be an integer-like value (excluding bool)')\\n\\n    try:\\n        n_int = operator.index(n)\\n    except Exception as exc:  # noqa: BLE001\\n        raise TypeError('n must be an integer-like value (excluding bool)') from exc\\n\\n    if n_int < 0:\\n        raise ValueError('n must be >= 0')\\n\\n    result = 1\\n    # Multiply 2..n inclusive\\n    for i in range(2, n_int + 1):\\n        result *= i\\n    return result\\n\\n\\nif __name__ == '__main__':\\n    import doctest\\n    failures, _ = doctest.testmod()\\n    raise SystemExit(0 if failures == 0 else 1)\\n"
      },
      {
        "path": "tests/test_factorial.py",
        "content": "import unittest\\n\\nfrom factorial import factorial\\n\\n\\nclass TestFactorial(unittest.TestCase):\\n    def test_small_values(self):\\n        self.assertEqual(factorial(0), 1)\\n        self.assertEqual(factorial(1), 1)\\n        self.assertEqual(factorial(5), 120)\\n        self.assertEqual(factorial(10), 3628800)\\n\\n    def test_large_value(self):\\n        # 20! = 2432902008176640000\\n        self.assertEqual(factorial(20), 2432902008176640000)\\n\\n    def test_negative_raises_value_error(self):\\n        with self.assertRaises(ValueError):\\n            factorial(-1)\\n\\n    def test_non_integral_raises_type_error(self):\\n        for bad in (3.14, 5.0, '3', object()):\\n            with self.assertRaises(TypeError):\\n                factorial(bad)\\n\\n    def test_bool_rejected(self):\\n        with self.assertRaises(TypeError):\\n            factorial(True)\\n        with self.assertRaises(TypeError):\\n            factorial(False)\\n\\n    def test_integral_like_via_index(self):\\n        class IntLike:\\n            def __index__(self):\\n                return 7\\n\\n        self.assertEqual(factorial(IntLike()), 5040)\\n\\n\\nif __name__ == '__main__':\\n    unittest.main(verbosity=2)\\n"
      },
      {
        "path": "README.md",
        "content": "# Factorial Utility\\n\\nA small, type-safe factorial implementation with doctests and unittests.\\n\\n## Features\\n- Accepts integer-like inputs via `__index__` (e.g., numpy integers).\\n- Explicitly rejects `bool` for API clarity.\\n- Raises `ValueError` for negative values; `TypeError` for non-integral inputs.\\n- Iterative (non-recursive) implementation to avoid recursion depth issues.\\n\\n## Usage\\n```bash\\npython -c \"from factorial import factorial; print(factorial(10))\"\\n# 3628800\\n```\\n\\n## Run Doctests\\n```bash\\npython -m factorial\\n```\\n\\n## Run Unit Tests\\n```bash\\npython -m unittest -v tests/test_factorial.py\\n```\\n\\n## Notes\\n- Behavior aligns with `math.factorial`: requires a non-negative integral value; rejects floats (even if integral like `5.0`).\\n- Integer-like objects implementing `__index__` are accepted; `bool` is rejected explicitly.\\n- Python integers are arbitrary precision; practical limits are time and memory for very large `n`.\\n"
      }
    ],
    "key_decisions": [
      "Use operator.index to accept integer-like values while rejecting floats",
      "Explicitly reject bool inputs for clarity despite bool being a subclass of int",
      "Raise TypeError for non-integral inputs and ValueError for negatives, matching math.factorial conventions",
      "Implement iterative multiplication to avoid recursion depth limits",
      "Provide doctest examples in the module and a unittest suite without external dependencies",
      "Omit a CLI to keep the module simple; doctest runner enabled via `python -m factorial`"
    ],
    "status": "complete",
    "_created_files": [
      "reports/aav3_real_sessions/aav3_real_0868319d/workspace/factorial.py",
      "reports/aav3_real_sessions/aav3_real_0868319d/workspace/tests/test_factorial.py",
      "reports/aav3_real_sessions/aav3_real_0868319d/workspace/README.md"
    ]
  }
}