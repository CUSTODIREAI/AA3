'''\nFactorial utility with strict, predictable validation.\n\n- Accepts int and int-like objects via __index__ (e.g., numpy.int64).\n- Explicitly rejects bools for API clarity.\n- Raises ValueError for negatives; TypeError for non-integral inputs.\n- Iterative implementation (avoids recursion depth issues).\n\nExamples (doctest):\n>>> factorial(0)\n1\n>>> factorial(5)\n120\n>>> factorial(10)\n3628800\n\nErrors (doctest):\n>>> factorial(-1)\nTraceback (most recent call last):\n...\nValueError: n must be >= 0\n>>> factorial(3.0)\nTraceback (most recent call last):\n...\nTypeError: n must be an integer-like value (excluding bool)\n>>> factorial(True)\nTraceback (most recent call last):\n...\nTypeError: n must be an integer-like value (excluding bool)\n\nAccept int-like objects via __index__ (doctest):\n>>> class I:\n...     def __index__(self): return 4\n...\n>>> factorial(I())\n24\n'''\n\nfrom typing import Any\nimport operator\n\n__all__ = ['factorial']\n\n\ndef factorial(n: int) -> int:\n    '''\n    Compute n! for a non-negative integer n using an iterative loop.\n\n    Validation rules:\n    - Reject bool explicitly.\n    - Accept int-like values via operator.index (e.g., numpy integers).\n    - Raise ValueError if n < 0.\n\n    Returns:\n        int: The factorial of n.\n    '''\n    if isinstance(n, bool):\n        raise TypeError('n must be an integer-like value (excluding bool)')\n\n    try:\n        n_int = operator.index(n)\n    except Exception as exc:  # noqa: BLE001\n        raise TypeError('n must be an integer-like value (excluding bool)') from exc\n\n    if n_int < 0:\n        raise ValueError('n must be >= 0')\n\n    result = 1\n    # Multiply 2..n inclusive\n    for i in range(2, n_int + 1):\n        result *= i\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    failures, _ = doctest.testmod()\n    raise SystemExit(0 if failures == 0 else 1)\n