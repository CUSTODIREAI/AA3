{
  "implementation": "Created a pure-Python factorial module with an iterative implementation, explicit input validation, and embedded doctests. A main guard runs doctests, quick assert checks, and a small unittest suite for basic coverage. Behavior mirrors math.factorial semantics for errors but explicitly rejects bool inputs.",
  "files_to_create": [
    {
      "path": "factorial.py",
      "content": "from typing import Final\n\n__all__ = [\"factorial\"]\n\n\ndef factorial(n: int) -> int:\n    \"\"\"\n    Compute the factorial of a non-negative integer n using an iterative approach.\n\n    Parameters\n    ----------\n    n : int\n        Non-negative integer.\n\n    Returns\n    -------\n    int\n        n! (the factorial of n).\n\n    Raises\n    ------\n    TypeError\n        If n is not an int (or is a bool).\n    ValueError\n        If n is negative.\n\n    Examples\n    --------\n    >>> factorial(0)\n    1\n    >>> factorial(1)\n    1\n    >>> factorial(5)\n    120\n    >>> factorial(10)\n    3628800\n    >>> factorial(20)\n    2432902008176640000\n\n    Error cases\n    >>> factorial(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be a non-negative integer\n    >>> factorial(3.5)\n    Traceback (most recent call last):\n    ...\n    TypeError: n must be an int, got float\n    >>> factorial(True)\n    Traceback (most recent call last):\n    ...\n    TypeError: n must be a plain int, not bool\n    \"\"\"\n    # Reject bool explicitly (even though bool is a subclass of int)\n    if isinstance(n, bool):\n        raise TypeError(\"n must be a plain int, not bool\")\n\n    if not isinstance(n, int):\n        raise TypeError(f\"n must be an int, got {type(n).__name__}\")\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    # Iterative multiplication avoids recursion depth limits\n    result: int = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\n\nif __name__ == \"__main__\":\n    # Run doctests and a few lightweight tests when executed directly\n    import doctest\n    import sys\n    import unittest\n\n    # Run doctests embedded in the docstring\n    failures, _ = doctest.testmod()\n    if failures:\n        # Exit early on doctest failures, mirroring typical CI behavior\n        sys.exit(1)\n\n    # Quick sanity asserts\n    assert factorial(2) == 2\n    assert factorial(6) == 720\n\n    class FactorialTests(unittest.TestCase):\n        def test_zero_and_one(self) -> None:\n            self.assertEqual(factorial(0), 1)\n            self.assertEqual(factorial(1), 1)\n\n        def test_small_values(self) -> None:\n            self.assertEqual(factorial(3), 6)\n            self.assertEqual(factorial(4), 24)\n            self.assertEqual(factorial(5), 120)\n\n        def test_large_value(self) -> None:\n            # Just a correctness spot-check; Python ints are arbitrary-precision\n            self.assertEqual(factorial(10), 3628800)\n\n        def test_type_errors(self) -> None:\n            with self.assertRaises(TypeError):\n                factorial(3.14)  # float\n            with self.assertRaises(TypeError):\n                factorial(True)  # explicit bool rejection\n            with self.assertRaises(TypeError):\n                factorial(\"3\")  # str\n\n        def test_value_error(self) -> None:\n            with self.assertRaises(ValueError):\n                factorial(-2)\n\n    # Run the unittest suite without exiting the interpreter (handy for REPL)\n    unittest.main(argv=[sys.argv[0]], exit=False)\n"
    }
  ],
  "key_decisions": [
    "Used a single module `factorial.py` per PEP 8, exposing a function-first API.",
    "Implemented iterative multiplication (no recursion) to avoid recursion depth limits.",
    "Applied strict runtime validation: reject negatives (ValueError), non-ints (TypeError), and explicitly reject bool.",
    "Kept type hints simple with `int` return and parameter; no CLI included to keep scope focused.",
    "Embedded doctests in the docstring and added a minimal unittest suite under the main guard.",
    "Chose clear, stable exception messages to make doctests reliable."
  ],
  "status": "complete"
}