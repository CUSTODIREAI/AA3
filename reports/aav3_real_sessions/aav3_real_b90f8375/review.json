{
  "implementation": "Created a single self-contained Python module implementing an iterative factorial with strict input validation, executable doctest examples, and inline assertions under a __main__ guard. The function accepts integer-like inputs via the __index__ protocol, explicitly rejects bool, raises ValueError for negatives, and computes factorial iteratively to avoid recursion limits. The __main__ block runs doctests, performs sanity checks against math.factorial for several values, validates large-n behavior, and verifies error conditions.",
  "files_to_create": [
    {
      "path": "factorial.py",
      "content": "from typing import SupportsIndex\nimport operator\n\n\ndef factorial(n: SupportsIndex) -> int:\n    \"\"\"\n    Compute n! for a non-negative integer n.\n\n    - Accepts integer-like inputs via the ``__index__`` protocol (e.g., int, NumPy integers).\n    - Explicitly rejects ``bool`` to avoid ambiguity.\n    - Raises ``ValueError`` for negative values.\n\n    Examples\n    --------\n    >>> factorial(0)\n    1\n    >>> factorial(1)\n    1\n    >>> factorial(6)\n    720\n    >>> factorial(20)\n    2432902008176640000\n\n    Non-integer numerics are rejected:\n    >>> factorial(5.0)\n    Traceback (most recent call last):\n    ...\n    TypeError: factorial() argument must be an integer-like value, not float\n\n    Negative values are rejected:\n    >>> factorial(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: factorial() not defined for negative values\n\n    Bool is not accepted:\n    >>> factorial(True)\n    Traceback (most recent call last):\n    ...\n    TypeError: factorial() does not accept bool\n    \"\"\"\n    if isinstance(n, bool):\n        raise TypeError(\"factorial() does not accept bool\")\n\n    try:\n        i = operator.index(n)\n    except TypeError:\n        raise TypeError(\n            f\"factorial() argument must be an integer-like value, not {type(n).__name__}\"\n        )\n\n    if i < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n\n    result = 1\n    for k in range(2, i + 1):\n        result *= k\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    import math\n    import sys\n\n    failed, _ = doctest.testmod()\n    if failed:\n        sys.exit(1)\n\n    # Basic correctness checks\n    assert factorial(0) == 1\n    assert factorial(1) == 1\n    assert factorial(5) == 120\n    assert factorial(6) == 720\n\n    # Cross-check several values vs math.factorial\n    for i in (0, 1, 2, 5, 10, 20, 50, 100, 200):\n        assert factorial(i) == math.factorial(i)\n\n    # Large n smoke test (performance/size sanity)\n    big = 1000\n    val = factorial(big)\n    assert isinstance(val, int) and val > 0\n\n    # Error cases\n    try:\n        factorial(-3)\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Expected ValueError for negative input\")\n\n    for bad in (3.14, 5.0, \"7\", None, [3], True, False):\n        try:\n            factorial(bad)\n        except TypeError:\n            pass\n        else:\n            raise AssertionError(f\"Expected TypeError for {bad!r}\")\n\n    print(\"All doctests and assertions passed.\")\n"
    }
  ],
  "key_decisions": [
    "Use operator.index to accept integer-like inputs (SupportsIndex) and raise TypeError for non-indexable types.",
    "Explicitly reject bool inputs with TypeError to avoid ambiguity from bool being a subclass of int.",
    "Iterative computation (range(2..n)) to avoid recursion depth issues and keep implementation simple and efficient.",
    "Raise ValueError for negative inputs with a clear, conventional error message.",
    "Provide executable doctest examples that cover success cases and error cases.",
    "Place inline assertions under __main__ to run doctests and quick checks without external frameworks.",
    "Cross-check selected values against math.factorial in tests for additional confidence while keeping production code independent."
  ],
  "status": "complete",
  "_created_files": [
    "reports/aav3_real_sessions/aav3_real_b90f8375/workspace/factorial.py"
  ]
}