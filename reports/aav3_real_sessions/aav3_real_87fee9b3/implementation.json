{
  "implementation": "Added a self-contained Python module implementing an iterative factorial function with strict input validation, doctest examples in the docstring, and a small unittest suite. Running the module directly executes doctests first and then the unittests under __main__.",
  "files_to_create": [
    {
      "path": "factorial.py",
      "content": "\"\"\"Factorial implementation with input validation and tests.\n\nThis module provides an iterative factorial implementation that validates inputs\nand includes both doctest examples and a small unittest suite. Running this\nfile directly will execute doctests first, then unittests.\n\nExamples\n--------\n>>> factorial(0)\n1\n>>> factorial(1)\n1\n>>> factorial(5)\n120\n>>> factorial(-1)\nTraceback (most recent call last):\n...\nValueError: n must be >= 0\n\"\"\"\nfrom __future__ import annotations\n\nimport numbers\nimport unittest\nfrom decimal import Decimal\n\n\ndef factorial(n: int) -> int:\n    \"\"\"Compute n! (n factorial) iteratively.\n\n    - Accepts only non-negative integers (excludes bool)\n    - Raises TypeError for non-integer inputs (including bool)\n    - Raises ValueError for negative integers\n\n    This avoids recursion to prevent recursion depth issues.\n\n    Parameters\n    ----------\n    n : int\n        Non-negative integer whose factorial to compute.\n\n    Returns\n    -------\n    int\n        The factorial of n.\n\n    Notes\n    -----\n    Factorial grows very quickly; very large inputs may be slow and consume\n    significant memory due to Python's arbitrary-precision integers.\n\n    Examples\n    --------\n    >>> factorial(0)\n    1\n    >>> factorial(1)\n    1\n    >>> factorial(5)\n    120\n    >>> factorial(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be >= 0\n    \"\"\"\n    # Strict type check: allow ints but explicitly reject booleans\n    if isinstance(n, bool) or not isinstance(n, numbers.Integral):\n        raise TypeError(\"n must be an integer (bool not allowed)\")\n\n    if n < 0:\n        raise ValueError(\"n must be >= 0\")\n\n    # Iterative approach to avoid recursion depth issues\n    result = 1\n    # Using int(n) to satisfy type checker; guarded by Integral check above\n    for i in range(2, int(n) + 1):\n        result *= i\n    return result\n\n\nclass TestFactorial(unittest.TestCase):\n    def test_zero_and_one(self) -> None:\n        self.assertEqual(factorial(0), 1)\n        self.assertEqual(factorial(1), 1)\n\n    def test_small_values(self) -> None:\n        self.assertEqual(factorial(5), 120)\n        self.assertEqual(factorial(10), 3_628_800)\n        self.assertEqual(factorial(20), 2_432_902_008_176_640_000)\n\n    def test_negative_raises_value_error(self) -> None:\n        with self.assertRaises(ValueError):\n            factorial(-1)\n        with self.assertRaises(ValueError):\n            factorial(-100)\n\n    def test_non_integer_raises_type_error(self) -> None:\n        bad_values = [\n            1.0,\n            3.14,\n            \"5\",\n            None,\n            complex(2, 0),\n            [5],\n            (5,),\n            {5},\n            Decimal(5),\n        ]\n        for val in bad_values:\n            with self.subTest(val=val):\n                with self.assertRaises(TypeError):\n                    factorial(val)  # type: ignore[arg-type]\n\n    def test_bool_rejected(self) -> None:\n        with self.assertRaises(TypeError):\n            factorial(True)  # type: ignore[arg-type]\n        with self.assertRaises(TypeError):\n            factorial(False)  # type: ignore[arg-type]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    import sys\n\n    # Run doctests first; if any fail, exit non-zero and skip unittests\n    failures, _ = doctest.testmod(optionflags=doctest.ELLIPSIS)\n    if failures:\n        sys.exit(1)\n\n    # Then run the unittest suite with verbosity\n    unittest.main(verbosity=2)\n"
    }
  ],
  "key_decisions": [
    "Chose a single self-contained module with function, doctests, and unittests to satisfy the __main__ execution requirement.",
    "Implemented iterative factorial to avoid recursion depth limits and match the plan.",
    "Performed strict type validation: accept integers only, explicitly reject bool, raise TypeError for non-integers and ValueError for negatives.",
    "Included doctest examples for 0, 1, 5, and a negative input error per plan.",
    "Added unittests covering typical values, a larger known value (20!), type errors, boolean rejection, and negative inputs.",
    "Ran doctests before unittests in __main__ so documentation examples act as a first gate."
  ],
  "status": "complete"
}